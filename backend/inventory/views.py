# inventory/views.py

from rest_framework import viewsets, status
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response

from logaccess.views import TenantScopedPermission
from logaccess.models import RoleType
from domains.models import get_product_model_for_tenant
from .serializers import get_serializer_for_domain, ProductBaseSerializer


class ProductViewSet(TenantScopedPermission, viewsets.ModelViewSet):
    """
    Single ViewSet for ALL product operations.
    The model and serializer it uses are resolved at runtime
    based on the authenticated user's tenant domain.

    Routes (auto-generated by the router):
      GET    /api/inventory/products/       → list
      POST   /api/inventory/products/       → create
      GET    /api/inventory/products/{id}/  → retrieve
      PUT    /api/inventory/products/{id}/  → update
      PATCH  /api/inventory/products/{id}/  → partial_update
      DELETE /api/inventory/products/{id}/  → destroy
    """

    permission_classes = [IsAuthenticated]

    # ── Dynamic queryset ─────────────────────────────────────────
    # We can't hardcode a queryset here because we don't know the
    # tenant until the request arrives. So we resolve it at runtime.
    def get_queryset(self):
        tenant = self.request.user.tenant
        if not tenant:
            from domains.models import Product

            return Product.objects.none()

        # 1. Look up the correct model for this tenant's domain
        ProductModel = get_product_model_for_tenant(tenant)
        # 2. Filter to ONLY this tenant's data
        return ProductModel.objects.filter(tenant=tenant)

    # ── Dynamic serializer ───────────────────────────────────────
    # Same logic: resolve at runtime based on tenant domain.
    def get_serializer_class(self):
        tenant = self.request.user.tenant
        if not tenant:
            return ProductBaseSerializer
        return get_serializer_for_domain(tenant.domain)

    # ── Inject tenant on create ──────────────────────────────────
    # The request body should NOT contain tenant — we set it server-side.
    # This prevents any user from forging a product into another tenant.
    def perform_create(self, serializer):
        serializer.save(tenant=self.request.user.tenant)

    # ── Permission gates ─────────────────────────────────────────
    # All staff can read (list/retrieve).
    # Only manager+ can create or update.
    # Only owner can delete.
    def create(self, request, *args, **kwargs):
        if not request.user.has_tenant_permission(RoleType.MANAGER):
            return Response(
                {"error": "Only managers or owners can add products."},
                status=status.HTTP_403_FORBIDDEN,
            )
        return super().create(request, *args, **kwargs)

    def update(self, request, *args, **kwargs):
        if not request.user.has_tenant_permission(RoleType.MANAGER):
            return Response(
                {"error": "Only managers or owners can update products."},
                status=status.HTTP_403_FORBIDDEN,
            )
        return super().update(request, *args, **kwargs)

    def destroy(self, request, *args, **kwargs):
        if not request.user.is_owner:
            return Response(
                {"error": "Only the owner can delete products."},
                status=status.HTTP_403_FORBIDDEN,
            )
        return super().destroy(request, *args, **kwargs)
